# input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!


# Reference object to connect posts to users 
# (each object/row only link to one user and one post)
# can't be @hasMany (timeline = many to many)
# user can hasve many timeline events, post can belong to many different timelines
# Timeline object = 1 user and 1 post
# Fetch me timeline objects for username1 ==> get many posts and sort by timestamp
# TImeline event
# GetTimeline - paginate with limit and order by dates descending
type Timeline 
  @model 
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "ownerID"
        provider: userPools
        operations: [read, create]
      }
    ]
  )
{
  # id: ID!
  ownerID: ID! @primaryKey(sortKeyFields: ["timestamp"])
    # @index(
    #     name: "TimelineBySpecificOwner",
    #     queryField: "listTimelinePostsBySpecificOwner",
    #     sortKeyFields: ["timestamp"] # sort posts-by-owner by time
    # )
  # ownerPointer: UserInfo @belongsTo(fields: ["ownerID"])
  postID: ID!
  post: Post
    @hasOne(
      # indexName: "PostsByTimeline",
      fields: ["postID"]
    )
  
  # TIME
  timestamp: Int!
  # type: String! # always should be `Post` - used in SortByTimestamp GSI
  #   @index(
  #       name: "TimelineByTimestamp"
  #       queryField: "listTimelineSortedByTimestamp"
  #       sortKeyFields: ["timestamp"] # sort posts by time overall
  #   )
}




# ====================== #
#          POST          #
# ====================== #

type Post @model
@auth(rules: [
  { allow: groups, groups: ["Admin"], operations: [read, update, delete] }
  { allow: groups, groups: ["Moderator"], operations: [read, update] }
  { allow: groups, groups: ["Analyst"], operations: [read] }
  { allow: owner, ownerField: "owner", provider: userPools, operations: [read, create, delete] }
  { allow: private, provider: userPools, operations: [read, update] }
  { allow: public, operations: [read, update] }
])
{
  id: ID
  content: String!
  owner: String
    @index(
        name: "BySpecificOwner",
        queryField: "listPostsBySpecificOwner",
        sortKeyFields: ["timestamp"] # sort posts-by-owner by time
    )
  userPointer: UserInfo @belongsTo(fields: ["owner"]) # Query UserInfo for the name that is equal to the owner username
  
  totalVisibility: Boolean @auth(rules: [{ allow: groups, groups: ["Admin", "Moderator"],operations: [read, update]  }]) # Remove from site or not
  feedVisibility: Boolean @auth(rules: [{ allow: groups, groups: ["Admin", "Moderator"],operations: [read, update]  }])  # Show public or not

  timestamp: Int!
  type: String! # always should be `Post` - used in SortByTimestamp GSI
    @index(
        name: "SortByTimestamp"
        queryField: "listPostsSortedByTimestamp"
        sortKeyFields: ["timestamp"] # sort posts by time overall
    )
  likes: [Like] @hasMany(
    indexName: "LikesByPost",
    fields: ["id"]
    ) 

  impressions: Int
}


# ====================== #
#          LIKE          #
# ====================== #

type Like @model 
@auth(rules: [
  { allow: owner, ownerField: "likeUserId", provider: userPools, operations: [create, read, update, delete] }
  { allow: private, provider: userPools, operations: [read] }
  { allow: public, operations: [read] }
])
{
  id: ID
  likeUserId: String # get likes by owner
    @index(
      name: "LikesByOwner"
      queryField: "listLikesByOwner"
      # sortKeyFields: ["postID"]
    )
  likeUserHandle: String
  createdAt: AWSDateTime
  post: Post @belongsTo(fields: ["postID"])
  postID: ID! @index( # get likes by posts
    name: "LikesByPost"
  )
}

# ====================== #
#   FOLLOW RELATIONSHIP  #
# ====================== #

type FollowRelationship @model
	@auth(rules: [
		{allow: owner, ownerField: "followerId", provider: userPools, operations:[read, create, delete]},
		{allow: private, provider: userPools, operations:[read]}
	])
{
  # id: ID

  followerId: ID! @primaryKey(sortKeyFields: ["followeeId"]) # you are the follower
    @index (
      name: "SortByFollowerId"
      queryField: "listFollowsByFollowerId"
      # sortKeyFields: ["followeeId"]
    )
  # followerIdUserPointer: UserInfo @belongsTo(fields: ["followerId"]) # Query UserInfo for the name that is equal to the owner username

  followeeId: ID! # you are being followed
    @index ( 
      name: "SortByFolloweeId"
      queryField: "listFollowsByFolloweeId"
      sortKeyFields: ["followerId"]
    )
  # followeeIdUserPointer: UserInfo @belongsTo(fields: ["followeeId"]) # Query UserInfo for the name that is equal to the owner username
	
  
  # followerId: ID! @index (  # username of person doing the following (me)
  #     name: "SortByFollowerId"
  #     sortKeyFields: ["followeeId"]
  #   )
	timestamp: Int! 
  # type: String! # always should be `Post` - used in SortByTimestamp GSI
  #   @index(
  #       name: "SortFollowRelationshipsByTimestamp"
  #       queryField: "listFollowRelationshipsSortedByTimestamp"
  #       sortKeyFields: ["timestamp"] # sort posts by time overall
  #   )
}

# Attempt
type FollowObject @model 
@auth(rules: [
  { allow: owner, ownerField: "followHead", provider: userPools, operations: [create, read, delete] }
  { allow: private, provider: userPools, operations: [read] }
  { allow: public, operations: [read] }
])
{
  id: ID
  followerID: ID! # user
    @index(
      name: "FollowsMadeBySpecificOwner"
      queryField: "listFollowsBySpecificOwner"
      # sortKeyFields: ["postID"]
    )
  followeeID: ID! # someone else's account
    @index(
      name: "FollowersOfSpecificOwner"
      queryField: "listOfFollowedAccounts"
      # sortKeyFields: ["postID"]
    )

  timestamp: Int

  createdAt: AWSDateTime
  
 
}

# ====================== #
#         USERS          #
# ====================== #

type UserInfo @model  
  @auth(rules: [
    {allow: owner, ownerField: "followerId", provider: userPools, operations:[read, create, update]}, #followerId - previous ownerField
		{allow: private, provider: userPools, operations:[read, update]}
    {allow: public, operations: [read, update]}
  ])
{
  name: String! @primaryKey
  realName: String
  handle: String
    @index(name: "byHandle", queryField: "userByHandle")
  aliasLowerCase: String
    @index(name: "handleLowerCaseCheck", queryField: "userByHandleLowerCaseCheck")
  post: [Post] 
    @hasMany(indexName: "BySpecificOwner", fields: ["name"])
  pictureURL: String
  bio: String
  premium: Boolean
  payment: [Payment] 
    @hasMany(indexName: "PaymentsBySpecificOwner", fields: ["name"]) 
    @auth(rules: [{ allow: owner }])
  
  # Who Follows a User (i.e. 10 people follow you) - FollowersOfSpecificOwner
  followersNumber: Int
  # followers: [FollowObject] 
  #   @hasMany(indexName: "FollowersOfSpecificOwner", fields: ["name"])

  # Who the User Follows (i.e. you follow 10 people) - FollowsMadeBySpecificOwner
  followingNumber: Int
  # following: [FollowObject]
  #   @hasMany(indexName: "FollowsMadeBySpecificOwner", fields: ["name"])
  impressions: Int

  # followerIdPointer: [FollowRelationship] 
  #   @hasMany(indexName: "SortByFollowerId", fields: ["name"])
  
  # followeeIdPointer: [FollowRelationship] 
  #   @hasMany(indexName: "SortByFolloweeId", fields: ["name"])

  # timeline: [Timeline]
  #   @hasMany(
  #     indexName: "TimelineBySpecificOwner", fields: ["name"]
  #     # sortKeyFields: ["timestamp"] # sort posts by time overall
  #     )
  #   @auth(rules: [{ allow: owner }])
}

# ====================== #
#         PAYMENT        #
# ====================== #

type Payment @model 
  @auth(rules: [
    {allow: owner, ownerField: "owner", provider: userPools, operations:[read, create, update] }
  ])
  {
  id: ID!
  owner: String! # username of user
    @index(
        name: "PaymentsBySpecificOwner",
        queryField: "listPaymentsBySpecificOwner",
        sortKeyFields: ["timestamp"] # sort posts-by-owner by time
    )
  typeOfPayment: String # monthly, yearly, lifetime
  costOfPayment: Int # cost of payment
  invoiceURL: String
  type: String!  # always should be `Payment` - used in SortByTimestamp GSI
    @index(
        name: "SortPaymentsByTimestamp"
        queryField: "listPaymentsSortedByTimestamp"
        sortKeyFields: ["timestamp"] # sort posts by time overall
    )
  timestamp: Int!  
  } 

# type UserInfoS3Bucket {
#   bucket: String!
#   region: String!
#   key: String!
# }                              