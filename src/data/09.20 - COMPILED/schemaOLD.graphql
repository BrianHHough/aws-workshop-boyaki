input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!



type Timeline @model {
  userId: ID!
  timestamp: Int!
  postId: ID!
  post: [Post] @hasMany(fields: ["postId"])
}

type Post @model
@auth(rules: [
  { allow: groups, groups: ["Admin"], operations: [read, update, delete] }
  { allow: groups, groups: ["Moderator"], operations: [read, update] }
  { allow: groups, groups: ["Analyst"], operations: [read] }
  { allow: owner, ownerField: "owner", provider: userPools, operations: [read, create, delete] }
  { allow: private, provider: userPools, operations: [read] }
  { allow: public, operations: [read] }
])
{
  id: ID
  content: String!
  owner: String
    @index(
        name: "BySpecificOwner",
        queryField: "listPostsBySpecificOwner",
        sortKeyFields: ["timestamp"] # sort posts-by-owner by time
    )
  userPointer: UserInfo @belongsTo(fields: ["owner"]) # Query UserInfo for the name that is equal to the owner username
  
  totalVisibility: Boolean @auth(rules: [{ allow: groups, groups: ["Admin", "Moderator"],operations: [read, update]  }]) # Remove from site or not
  feedVisibility: Boolean @auth(rules: [{ allow: groups, groups: ["Admin", "Moderator"],operations: [read, update]  }])  # Show public or not

  timestamp: Int!
  type: String! # always should be `Post` - used in SortByTimestamp GSI
    @index(
        name: "SortByTimestamp"
        queryField: "listPostsSortedByTimestamp"
        sortKeyFields: ["timestamp"] # sort posts by time overall
    )
  likes: [Like] @hasMany(
    indexName: "LikesByPost",
    fields: ["id"]
    ) 

}

type Like @model 
@auth(rules: [
  { allow: owner, ownerField: "likeUserId", provider: userPools, operations: [create, read, update, delete] }
  { allow: private, provider: userPools, operations: [read] }
  { allow: public, operations: [read] }
])
{
  id: ID
  likeUserId: String # get likes by owner
    @index(
      name: "LikesByOwner"
      queryField: "listLikesByOwner"
      # sortKeyFields: ["postID"]
    )
  likeUserHandle: String
  createdAt: AWSDateTime
  post: Post @belongsTo(fields: ["postID"])
  postID: ID! @index( # get likes by posts
    name: "LikesByPost"
  )
}

type FollowRelationship @model
	@auth(rules: [
		{allow: owner, ownerField: "followerId", provider: userPools, operations:[read, create, delete]},
		{allow: private, provider: userPools, operations:[read]}
	])
{
  # id: ID
  followeeId: ID! # username of person being followed (someone else) 
    # @index ( 
    #   name: "SortByFolloweeId"
    #   sortKeyFields: ["followerId"]
    # )
	followerId: ID! @primaryKey(sortKeyFields: ["followeeId"]) # me
  
  # followerId: ID! @index (  # username of person doing the following (me)
  #     name: "SortByFollowerId"
  #     sortKeyFields: ["followeeId"]
  #   )
	timestamp: Int! 
}

type UserInfo @model  
  @auth(rules: [
    {allow: owner, ownerField: "followerId", provider: userPools, operations:[read, create, update]}, #followerId - previous ownerField
		{allow: private, provider: userPools, operations:[read]}
    { allow: public, operations: [read] }
  ])
{
  name: String! @primaryKey
  realName: String
  handle: String
  post: [Post] @hasMany(indexName: "BySpecificOwner", fields: ["name"])
  pictureURL: String
  bio: String
  premium: Boolean
  payment: [Payment] 
    @hasMany(indexName: "PaymentsBySpecificOwner", fields: ["name"]) 
    @auth(rules: [{ allow: owner }])
}

type Payment @model 
  @auth(rules: [
    {allow: owner, ownerField: "owner", provider: userPools, operations:[read, create, update] }
  ])
  {
  id: ID!
  owner: String! # username of user
    @index(
        name: "PaymentsBySpecificOwner",
        queryField: "listPaymentsBySpecificOwner",
        sortKeyFields: ["timestamp"] # sort posts-by-owner by time
    )
  typeOfPayment: String # monthly, yearly, lifetime
  costOfPayment: Int # cost of payment
  invoiceURL: String
  type: String!  # always should be `Payment` - used in SortByTimestamp GSI
    @index(
        name: "SortPaymentsByTimestamp"
        queryField: "listPaymentsSortedByTimestamp"
        sortKeyFields: ["timestamp"] # sort posts by time overall
    )
  timestamp: Int!  
  } 

# type UserInfoS3Bucket {
#   bucket: String!
#   region: String!
#   key: String!
# }